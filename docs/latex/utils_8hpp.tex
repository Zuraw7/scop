\doxysection{/home/zuraw/\+Desktop/42-\/advanced-\/core/scop/src/utils/utils.hpp File Reference}
\hypertarget{utils_8hpp}{}\label{utils_8hpp}\index{/home/zuraw/Desktop/42-\/advanced-\/core/scop/src/utils/utils.hpp@{/home/zuraw/Desktop/42-\/advanced-\/core/scop/src/utils/utils.hpp}}


Header file for all utility functions from utils directory.  


{\ttfamily \#include $<$array$>$}\newline
{\ttfamily \#include $<$cmath$>$}\newline
{\ttfamily \#include $<$GL/glew.\+h$>$}\newline
{\ttfamily \#include $<$GLFW/glfw3.\+h$>$}\newline
{\ttfamily \#include "{}../core/\+Object.\+hpp"{}}\newline
{\ttfamily \#include "{}../render/\+Renderer.\+hpp"{}}\newline
Include dependency graph for utils.\+hpp\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp__dep__incl}
\end{center}
\end{figure}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{utils_8hpp_a8ddd68a4ac892a57df0a9f9d1c0cd4db}\label{utils_8hpp_a8ddd68a4ac892a57df0a9f9d1c0cd4db} 
double {\bfseries to\+Radians} (const double x)
\item 
void \mbox{\hyperlink{utils_8hpp_a75f161a826159ff1851ef0a98c787a3d}{process\+Input}} (GLFWwindow \texorpdfstring{$\ast$}{*}window, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classObject}{Object}} $>$ \&object, \mbox{\hyperlink{classRenderer}{Renderer}} \&renderer, double delta\+TIme)
\begin{DoxyCompactList}\small\item\em Processes all input for the current frame. \end{DoxyCompactList}\item 
std\+::array$<$ float, 16 $>$ \mbox{\hyperlink{utils_8hpp_ac180e611998d6d9c55efa0cd55033f94}{get\+Perspective}} (const float fov, const float aspect\+Ratio, const float near, const float far)
\begin{DoxyCompactList}\small\item\em Creates a perspective projection matrix. \end{DoxyCompactList}\item 
std\+::array$<$ float, 16 $>$ \mbox{\hyperlink{utils_8hpp_ae174908cce46421f38469803bfa59f5a}{translate\+Matrix}} (const std\+::array$<$ float, 16 $>$ \&mat, const float x, const float y, const float z)
\begin{DoxyCompactList}\small\item\em Translates a 4x4 transformation matrix. \end{DoxyCompactList}\item 
std\+::array$<$ float, 16 $>$ \mbox{\hyperlink{utils_8hpp_a1e1e8660fcecd7c15f917a2a41102d2b}{scale\+Matrix}} (const std\+::array$<$ float, 16 $>$ \&matrix, const float scale\+Factor)
\begin{DoxyCompactList}\small\item\em Scales a 4x4 matrix uniformly. \end{DoxyCompactList}\item 
std\+::array$<$ float, 16 $>$ \mbox{\hyperlink{utils_8hpp_a76d118ab7f488b1894ea56752c30fad2}{multiply\+Matrix}} (const std\+::array$<$ float, 16 $>$ \&mat1, const std\+::array$<$ float, 16 $>$ \&mat2)
\begin{DoxyCompactList}\small\item\em Multiplies two 4x4 matrices. \end{DoxyCompactList}\item 
std\+::array$<$ float, 16 $>$ \mbox{\hyperlink{utils_8hpp_af7b80c3132eeb77e03594e884ad2aa92}{get\+Rotation\+MatrixY}} (const float angle)
\begin{DoxyCompactList}\small\item\em Creates a rotation matrix for rotation around the Y-\/axis. \end{DoxyCompactList}\item 
std\+::array$<$ float, 16 $>$ \mbox{\hyperlink{utils_8hpp_a1e1bbdd420829f16ffff997480c3cc30}{get\+Identity\+Mat4}} ()
\begin{DoxyCompactList}\small\item\em Returns a 4x4 identity matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{utils_8hpp_a89e39c082651b80483f72e5f8319df47}{print\+Matrix}} (const std\+::array$<$ float, 16 $>$ \&mat, const std\+::string \&name)
\begin{DoxyCompactList}\small\item\em Prints a 4x4 matrix to the console. \end{DoxyCompactList}\item 
std\+::array$<$ float, 3 $>$ \mbox{\hyperlink{utils_8hpp_a1ceb84441ee1328801fd719d8b3bb40c}{subtract\+Vec}} (const std\+::array$<$ float, 3 $>$ \&a, const std\+::array$<$ float, 3 $>$ \&b)
\begin{DoxyCompactList}\small\item\em Subtracts one 3D vector from another. \end{DoxyCompactList}\item 
std\+::array$<$ float, 3 $>$ \mbox{\hyperlink{utils_8hpp_a2ee4703a6190ca3dd292bae5f26be183}{add\+Vec}} (const std\+::array$<$ float, 3 $>$ \&a, const std\+::array$<$ float, 3 $>$ \&b)
\begin{DoxyCompactList}\small\item\em Adds two 3D vectors. \end{DoxyCompactList}\item 
std\+::array$<$ float, 3 $>$ \mbox{\hyperlink{utils_8hpp_a242aa56681b3b3c2c382ecb71aa277df}{normalize\+Vec}} (const std\+::array$<$ float, 3 $>$ \&vec)
\begin{DoxyCompactList}\small\item\em Normalizes a 3D vector. \end{DoxyCompactList}\item 
std\+::array$<$ float, 3 $>$ \mbox{\hyperlink{utils_8hpp_a2b4011ef615602166da022d080bfe141}{cross\+Prod\+Vec}} (const std\+::array$<$ float, 3 $>$ \&a, const std\+::array$<$ float, 3 $>$ \&b)
\begin{DoxyCompactList}\small\item\em Computes the cross product of two 3D vectors. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{utils_8hpp_a763d705143c1f3dc35b336cfdc04fd34}{dot\+Prod\+Vec}} (const std\+::array$<$ float, 3 $>$ \&a, const std\+::array$<$ float, 3 $>$ \&b)
\begin{DoxyCompactList}\small\item\em Computes the dot product (scalar product) of two 3D vectors. \end{DoxyCompactList}\item 
std\+::array$<$ float, 3 $>$ \mbox{\hyperlink{utils_8hpp_a6f9c9b93d61d589f2cd639696ee13c31}{multiply\+Vec\+By\+Float}} (const std\+::array$<$ float, 3 $>$ \&vec, float x)
\begin{DoxyCompactList}\small\item\em Multiplies a 3D vector by a scalar value. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{utils_8hpp_a09882d71c70e402a1d6179c914a001c2}{framebuffer\+Size\+Callback}} (GLFWwindow \texorpdfstring{$\ast$}{*}window, int width, int height)
\begin{DoxyCompactList}\small\item\em Callback function for framebuffer size changes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{utils_8hpp_ae49f0c4c2064be8fbcf555f46460b7df}{cursor\+Pos\+Callback}} (GLFWwindow \texorpdfstring{$\ast$}{*}window, double xpos, double ypos)
\begin{DoxyCompactList}\small\item\em Callback function for mouse movement. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{utils_8hpp_aa9b224479e8c1cc5251b8e7f3fdabacd}{scroll\+Callback}} (GLFWwindow \texorpdfstring{$\ast$}{*}window, double xoffset, double yoffset)
\begin{DoxyCompactList}\small\item\em Callback function for scroll input. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Header file for all utility functions from utils directory. 

\begin{DoxyAuthor}{Author}
Patryk 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
0.\+1 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
12-\/11-\/2025
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Copyright (c) 2025 
\end{DoxyCopyright}


\doxysubsection{Function Documentation}
\Hypertarget{utils_8hpp_a2ee4703a6190ca3dd292bae5f26be183}\label{utils_8hpp_a2ee4703a6190ca3dd292bae5f26be183} 
\index{utils.hpp@{utils.hpp}!addVec@{addVec}}
\index{addVec@{addVec}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{addVec()}{addVec()}}
{\footnotesize\ttfamily std\+::array$<$ float, 3 $>$ add\+Vec (\begin{DoxyParamCaption}\item[{const std\+::array$<$ float, 3 $>$ \&}]{a,  }\item[{const std\+::array$<$ float, 3 $>$ \&}]{b }\end{DoxyParamCaption})}



Adds two 3D vectors. 


\begin{DoxyParams}{Parameters}
{\em a} & The first vector. \\
\hline
{\em b} & The second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new vector representing the sum (a + b). 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=318pt]{utils_8hpp_a2ee4703a6190ca3dd292bae5f26be183_icgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_a2b4011ef615602166da022d080bfe141}\label{utils_8hpp_a2b4011ef615602166da022d080bfe141} 
\index{utils.hpp@{utils.hpp}!crossProdVec@{crossProdVec}}
\index{crossProdVec@{crossProdVec}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{crossProdVec()}{crossProdVec()}}
{\footnotesize\ttfamily std\+::array$<$ float, 3 $>$ cross\+Prod\+Vec (\begin{DoxyParamCaption}\item[{const std\+::array$<$ float, 3 $>$ \&}]{a,  }\item[{const std\+::array$<$ float, 3 $>$ \&}]{b }\end{DoxyParamCaption})}



Computes the cross product of two 3D vectors. 

Returns a vector that is perpendicular to both input vectors. The result follows the right-\/hand rule.


\begin{DoxyParams}{Parameters}
{\em a} & The first input vector. \\
\hline
{\em b} & The second input vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The cross product of vector a and b. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp_a2b4011ef615602166da022d080bfe141_icgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_ae49f0c4c2064be8fbcf555f46460b7df}\label{utils_8hpp_ae49f0c4c2064be8fbcf555f46460b7df} 
\index{utils.hpp@{utils.hpp}!cursorPosCallback@{cursorPosCallback}}
\index{cursorPosCallback@{cursorPosCallback}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{cursorPosCallback()}{cursorPosCallback()}}
{\footnotesize\ttfamily void cursor\+Pos\+Callback (\begin{DoxyParamCaption}\item[{GLFWwindow \texorpdfstring{$\ast$}{*}}]{window,  }\item[{double}]{xpos,  }\item[{double}]{ypos }\end{DoxyParamCaption})}



Callback function for mouse movement. 

Tracks the cursor position and updates the camera\textquotesingle{}s direction based on mouse movement. Handles first-\/mouse initialization to prevent large jumps on the first frame.


\begin{DoxyParams}{Parameters}
{\em window} & The GLFW window that triggered the callback. \\
\hline
{\em xpos} & Current X position of the cursor. \\
\hline
{\em ypos} & Current Y position of the cursor. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp_ae49f0c4c2064be8fbcf555f46460b7df_cgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_a763d705143c1f3dc35b336cfdc04fd34}\label{utils_8hpp_a763d705143c1f3dc35b336cfdc04fd34} 
\index{utils.hpp@{utils.hpp}!dotProdVec@{dotProdVec}}
\index{dotProdVec@{dotProdVec}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{dotProdVec()}{dotProdVec()}}
{\footnotesize\ttfamily float dot\+Prod\+Vec (\begin{DoxyParamCaption}\item[{const std\+::array$<$ float, 3 $>$ \&}]{a,  }\item[{const std\+::array$<$ float, 3 $>$ \&}]{b }\end{DoxyParamCaption})}



Computes the dot product (scalar product) of two 3D vectors. 

Measures how aligned two vectors are with each other. A result of 1 means they point in the same direction, 0 means they are perpendicular, and -\/1 means they are opposite.


\begin{DoxyParams}{Parameters}
{\em a} & The first input vector. \\
\hline
{\em b} & The second input vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The dot product value (a \texorpdfstring{$\ast$}{*} b). 
\end{DoxyReturn}
\Hypertarget{utils_8hpp_a09882d71c70e402a1d6179c914a001c2}\label{utils_8hpp_a09882d71c70e402a1d6179c914a001c2} 
\index{utils.hpp@{utils.hpp}!framebufferSizeCallback@{framebufferSizeCallback}}
\index{framebufferSizeCallback@{framebufferSizeCallback}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{framebufferSizeCallback()}{framebufferSizeCallback()}}
{\footnotesize\ttfamily void framebuffer\+Size\+Callback (\begin{DoxyParamCaption}\item[{GLFWwindow \texorpdfstring{$\ast$}{*}}]{window,  }\item[{int}]{width,  }\item[{int}]{height }\end{DoxyParamCaption})}



Callback function for framebuffer size changes. 

Updates the Open\+GL viewport to match the new window dimensions.


\begin{DoxyParams}{Parameters}
{\em window} & The GLFW window that triggered the callback. \\
\hline
{\em width} & New width of the framebuffer. \\
\hline
{\em height} & New height of the framebuffer. \\
\hline
\end{DoxyParams}
\Hypertarget{utils_8hpp_a1e1bbdd420829f16ffff997480c3cc30}\label{utils_8hpp_a1e1bbdd420829f16ffff997480c3cc30} 
\index{utils.hpp@{utils.hpp}!getIdentityMat4@{getIdentityMat4}}
\index{getIdentityMat4@{getIdentityMat4}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{getIdentityMat4()}{getIdentityMat4()}}
{\footnotesize\ttfamily std\+::array$<$ float, 16 $>$ get\+Identity\+Mat4 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns a 4x4 identity matrix. 

The identity matrix has 1s on the diagonal and 0s elsewhere. It represents a “no transformation” state.

\begin{DoxyReturn}{Returns}
std\+::array$<$float, 16$>$ Identity matrix. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp_a1e1bbdd420829f16ffff997480c3cc30_icgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_ac180e611998d6d9c55efa0cd55033f94}\label{utils_8hpp_ac180e611998d6d9c55efa0cd55033f94} 
\index{utils.hpp@{utils.hpp}!getPerspective@{getPerspective}}
\index{getPerspective@{getPerspective}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{getPerspective()}{getPerspective()}}
{\footnotesize\ttfamily std\+::array$<$ float, 16 $>$ get\+Perspective (\begin{DoxyParamCaption}\item[{const float}]{fov,  }\item[{const float}]{aspect\+Ratio,  }\item[{const float}]{near,  }\item[{const float}]{far }\end{DoxyParamCaption})}



Creates a perspective projection matrix. 

Generates a projection matrix using the specified field of view, aspect ratio, and near/far clipping planes. Used to simulate depth in 3D rendering.


\begin{DoxyParams}{Parameters}
{\em fov} & Field of view in degrees. \\
\hline
{\em aspect\+Ratio} & Ratio of the viewport width to height. \\
\hline
{\em near} & Distance to the near clipping plane. \\
\hline
{\em far} & Distance to the far clipping plane. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::array$<$float, 16$>$ 4x4 perspective projection matrix. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp_ac180e611998d6d9c55efa0cd55033f94_icgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_af7b80c3132eeb77e03594e884ad2aa92}\label{utils_8hpp_af7b80c3132eeb77e03594e884ad2aa92} 
\index{utils.hpp@{utils.hpp}!getRotationMatrixY@{getRotationMatrixY}}
\index{getRotationMatrixY@{getRotationMatrixY}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{getRotationMatrixY()}{getRotationMatrixY()}}
{\footnotesize\ttfamily std\+::array$<$ float, 16 $>$ get\+Rotation\+MatrixY (\begin{DoxyParamCaption}\item[{const float}]{angle }\end{DoxyParamCaption})}



Creates a rotation matrix for rotation around the Y-\/axis. 

Returns a 4x4 rotation matrix that rotates points around the Y-\/axis by the specified angle.


\begin{DoxyParams}{Parameters}
{\em angle} & Rotation angle in radians. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::array$<$float, 16$>$ Y-\/axis rotation matrix. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp_af7b80c3132eeb77e03594e884ad2aa92_icgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_a76d118ab7f488b1894ea56752c30fad2}\label{utils_8hpp_a76d118ab7f488b1894ea56752c30fad2} 
\index{utils.hpp@{utils.hpp}!multiplyMatrix@{multiplyMatrix}}
\index{multiplyMatrix@{multiplyMatrix}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{multiplyMatrix()}{multiplyMatrix()}}
{\footnotesize\ttfamily std\+::array$<$ float, 16 $>$ multiply\+Matrix (\begin{DoxyParamCaption}\item[{const std\+::array$<$ float, 16 $>$ \&}]{mat1,  }\item[{const std\+::array$<$ float, 16 $>$ \&}]{mat2 }\end{DoxyParamCaption})}



Multiplies two 4x4 matrices. 

Performs standard matrix multiplication of two 4x4 matrices (mat1 \texorpdfstring{$\ast$}{*} mat2).


\begin{DoxyParams}{Parameters}
{\em mat1} & The first matrix (left operand). \\
\hline
{\em mat2} & The second matrix (right operand). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::array$<$float, 16$>$ The resulting matrix. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp_a76d118ab7f488b1894ea56752c30fad2_icgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_a6f9c9b93d61d589f2cd639696ee13c31}\label{utils_8hpp_a6f9c9b93d61d589f2cd639696ee13c31} 
\index{utils.hpp@{utils.hpp}!multiplyVecByFloat@{multiplyVecByFloat}}
\index{multiplyVecByFloat@{multiplyVecByFloat}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{multiplyVecByFloat()}{multiplyVecByFloat()}}
{\footnotesize\ttfamily std\+::array$<$ float, 3 $>$ multiply\+Vec\+By\+Float (\begin{DoxyParamCaption}\item[{const std\+::array$<$ float, 3 $>$ \&}]{vec,  }\item[{float}]{x }\end{DoxyParamCaption})}



Multiplies a 3D vector by a scalar value. 

Scales the vector uniformly in all directions by the given scalar.


\begin{DoxyParams}{Parameters}
{\em vec} & The input vector. \\
\hline
{\em x} & The scalar value to multiply by. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new scaled vector. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp_a6f9c9b93d61d589f2cd639696ee13c31_icgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_a242aa56681b3b3c2c382ecb71aa277df}\label{utils_8hpp_a242aa56681b3b3c2c382ecb71aa277df} 
\index{utils.hpp@{utils.hpp}!normalizeVec@{normalizeVec}}
\index{normalizeVec@{normalizeVec}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{normalizeVec()}{normalizeVec()}}
{\footnotesize\ttfamily std\+::array$<$ float, 3 $>$ normalize\+Vec (\begin{DoxyParamCaption}\item[{const std\+::array$<$ float, 3 $>$ \&}]{vec }\end{DoxyParamCaption})}



Normalizes a 3D vector. 

Converts the vector into a unit vector (length = 1) while preserving its direction. If the input vector has zero length, a zero vector is returned to avoid division by zero.


\begin{DoxyParams}{Parameters}
{\em vec} & The input vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A normalized version of the input vector. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp_a242aa56681b3b3c2c382ecb71aa277df_icgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_a89e39c082651b80483f72e5f8319df47}\label{utils_8hpp_a89e39c082651b80483f72e5f8319df47} 
\index{utils.hpp@{utils.hpp}!printMatrix@{printMatrix}}
\index{printMatrix@{printMatrix}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{printMatrix()}{printMatrix()}}
{\footnotesize\ttfamily void print\+Matrix (\begin{DoxyParamCaption}\item[{const std\+::array$<$ float, 16 $>$ \&}]{mat,  }\item[{const std\+::string \&}]{name }\end{DoxyParamCaption})}



Prints a 4x4 matrix to the console. 


\begin{DoxyParams}{Parameters}
{\em mat} & The matrix to print. \\
\hline
{\em name} & Optional name to display before the matrix. \\
\hline
\end{DoxyParams}
\Hypertarget{utils_8hpp_a75f161a826159ff1851ef0a98c787a3d}\label{utils_8hpp_a75f161a826159ff1851ef0a98c787a3d} 
\index{utils.hpp@{utils.hpp}!processInput@{processInput}}
\index{processInput@{processInput}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{processInput()}{processInput()}}
{\footnotesize\ttfamily void process\+Input (\begin{DoxyParamCaption}\item[{GLFWwindow \texorpdfstring{$\ast$}{*}}]{window,  }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classObject}{Object}} $>$ \&}]{object,  }\item[{\mbox{\hyperlink{classRenderer}{Renderer}} \&}]{renderer,  }\item[{double}]{delta\+Time }\end{DoxyParamCaption})}



Processes all input for the current frame. 

Handles closing the window, changing rendering modes, moving the object, and moving the camera based on key presses.


\begin{DoxyParams}{Parameters}
{\em window} & Pointer to the GLFW window. \\
\hline
{\em object} & Reference to the object being controlled. \\
\hline
{\em renderer} & Reference to the renderer. \\
\hline
{\em delta\+Time} & Time elapsed since the last frame (used for frame-\/rate-\/independent movement). \\
\hline
\end{DoxyParams}
\Hypertarget{utils_8hpp_a1e1e8660fcecd7c15f917a2a41102d2b}\label{utils_8hpp_a1e1e8660fcecd7c15f917a2a41102d2b} 
\index{utils.hpp@{utils.hpp}!scaleMatrix@{scaleMatrix}}
\index{scaleMatrix@{scaleMatrix}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{scaleMatrix()}{scaleMatrix()}}
{\footnotesize\ttfamily std\+::array$<$ float, 16 $>$ scale\+Matrix (\begin{DoxyParamCaption}\item[{const std\+::array$<$ float, 16 $>$ \&}]{matrix,  }\item[{const float}]{scale\+Factor }\end{DoxyParamCaption})}



Scales a 4x4 matrix uniformly. 

Applies a uniform scaling transformation to the matrix using the given scale factor.


\begin{DoxyParams}{Parameters}
{\em matrix} & Input matrix to scale. \\
\hline
{\em scale\+Factor} & Uniform scaling factor. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::array$<$float, 16$>$ Scaled matrix. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=291pt]{utils_8hpp_a1e1e8660fcecd7c15f917a2a41102d2b_icgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_aa9b224479e8c1cc5251b8e7f3fdabacd}\label{utils_8hpp_aa9b224479e8c1cc5251b8e7f3fdabacd} 
\index{utils.hpp@{utils.hpp}!scrollCallback@{scrollCallback}}
\index{scrollCallback@{scrollCallback}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{scrollCallback()}{scrollCallback()}}
{\footnotesize\ttfamily void scroll\+Callback (\begin{DoxyParamCaption}\item[{GLFWwindow \texorpdfstring{$\ast$}{*}}]{window,  }\item[{double}]{xoffset,  }\item[{double}]{yoffset }\end{DoxyParamCaption})}



Callback function for scroll input. 

Updates the camera\textquotesingle{}s zoom level based on vertical scroll offset.


\begin{DoxyParams}{Parameters}
{\em window} & The GLFW window that triggered the callback. \\
\hline
{\em xoffset} & Horizontal scroll offset (unused). \\
\hline
{\em yoffset} & Vertical scroll offset. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp_aa9b224479e8c1cc5251b8e7f3fdabacd_cgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_a1ceb84441ee1328801fd719d8b3bb40c}\label{utils_8hpp_a1ceb84441ee1328801fd719d8b3bb40c} 
\index{utils.hpp@{utils.hpp}!subtractVec@{subtractVec}}
\index{subtractVec@{subtractVec}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{subtractVec()}{subtractVec()}}
{\footnotesize\ttfamily std\+::array$<$ float, 3 $>$ subtract\+Vec (\begin{DoxyParamCaption}\item[{const std\+::array$<$ float, 3 $>$ \&}]{a,  }\item[{const std\+::array$<$ float, 3 $>$ \&}]{b }\end{DoxyParamCaption})}



Subtracts one 3D vector from another. 


\begin{DoxyParams}{Parameters}
{\em a} & The first vector. \\
\hline
{\em b} & The second vector to subtract from the first. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new vector representing the difference (a -\/ b). 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=340pt]{utils_8hpp_a1ceb84441ee1328801fd719d8b3bb40c_icgraph}
\end{center}
\end{figure}
\Hypertarget{utils_8hpp_ae174908cce46421f38469803bfa59f5a}\label{utils_8hpp_ae174908cce46421f38469803bfa59f5a} 
\index{utils.hpp@{utils.hpp}!translateMatrix@{translateMatrix}}
\index{translateMatrix@{translateMatrix}!utils.hpp@{utils.hpp}}
\doxysubsubsection{\texorpdfstring{translateMatrix()}{translateMatrix()}}
{\footnotesize\ttfamily std\+::array$<$ float, 16 $>$ translate\+Matrix (\begin{DoxyParamCaption}\item[{const std\+::array$<$ float, 16 $>$ \&}]{mat,  }\item[{const float}]{x,  }\item[{const float}]{y,  }\item[{const float}]{z }\end{DoxyParamCaption})}



Translates a 4x4 transformation matrix. 

Applies a translation (movement) to the given matrix by the specified x, y, and z offsets.


\begin{DoxyParams}{Parameters}
{\em mat} & The input matrix. \\
\hline
{\em x} & Translation distance along the X-\/axis. \\
\hline
{\em y} & Translation distance along the Y-\/axis. \\
\hline
{\em z} & Translation distance along the Z-\/axis. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::array$<$float, 16$>$ The translated matrix. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{utils_8hpp_ae174908cce46421f38469803bfa59f5a_icgraph}
\end{center}
\end{figure}
